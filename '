import React, { FC, useState } from 'react';
import useInterval from '../hooks/useInterval';
importa type { IParticle, IRocket, IXY } from '../interfaces/internal';
import './Firework.css';

interface Props {
  width: number;
  height: number;
  maxParticles: number;
}

class Particle {
  shrink: number;
  size: number;
  resistance: number;
  gravity: number;
  flick: boolean;
  alpha: number;
  fade: number;
  color: number;
  pos: IXY;
  vel: IXY;

  constructor(pos: IXY) {
    this.pos = { x: pos ? pos.x : 0, y: pos ? pos.y : 0 };
    this.vel = { x: 0, y: 0 };
    this.shrink = 0.97;
    this.size = 2;
    this.resistance = 1;
    this.gravity = 0;
    this.flick = false;
    this.alpha = 1;
    this.fade = 0;
    this.color = 0;
  }

  update() {
    // this.vel.x *= this.resistance;
    // this.vel.y *= this.resistance;
    // this.vel.y += this.gravity;
    // this.pos.x += this.vel.x;
    // this.pos.y += this.vel.y;
    // this.size *= this.shrink;
    // this.alpha -= this.fade;
  }

  exists() {
    return true;
    // return this.alpha >= 0.1 && this.size >= 1;
  }
}

class Rocket extends Particle {
  explosionColor: number;

  constructor(x: number, y: number) {
    super({ x, y });
    this.explosionColor = 0;
  }

  explode(pushParticles: (p: Particle[]) => void) {
    var count = Math.random() * 10 + 80;

    let thisParticles = [];
    for (var i = 0; i < count; i++) {
      var particle = new Particle(this.pos);
      var angle = Math.random() * Math.PI * 2;
      var speed = Math.cos((Math.random() * Math.PI) / 2) * 15;
      particle.vel.x = Math.cos(angle) * speed;
      particle.vel.y = Math.sin(angle) * speed;
      particle.size = 10;
      particle.gravity = 0.2;
      particle.resistance = 0.92;
      particle.shrink = Math.random() * 0.05 + 0.93;
      particle.flick = true;
      particle.color = this.explosionColor;
      thisParticles.push(particle);
    }
    pushParticles(thisParticles);
  }
}

const Firework: FC<Props> = ({ width, height, maxParticles }) => {
  const [rockets, setRockets] = useState<Rocket[]>([]);
  const [particles, setParticles] = useState<Particle[]>([]);

  const loop = () => {
    var existingRockets = [];

    for (var i = 0; i < rockets.length; i++) {
      // update and render
      rockets[i].update();
      // rockets[i].render(context);

      var distance = Math.sqrt(
        Math.pow(width - rockets[i].pos.x, 2) +
          Math.pow(height - rockets[i].pos.y, 2),
      );

      var randomChance =
        rockets[i].pos.y < (height * 2) / 3 ? Math.random() * 100 <= 1 : false;

      if (
        rockets[i].pos.y < height / 5 ||
        rockets[i].vel.y >= 0 ||
        distance < 50 ||
        randomChance
      ) {
        rockets[i].explode((p: Particle[]) => {
          setParticles([...particles, ...p]);
        });
      } else {
        existingRockets.push(rockets[i]);
      }
    }

    setRockets(existingRockets);

    var existingParticles = [];

    for (i = 0; i < particles.length; i++) {
      particles[i].update();

      // render and save particles that can be rendered
      if (particles[i].exists()) {
        // particles[i].render(context);
        existingParticles.push(particles[i]);
      }
    }

    // update array with existing particles - old particles should be garbage collected
    setParticles(existingParticles);

    while (particles.length > maxParticles) {
      particles.shift();
    }
  };

  const launch = () => {
    if (rockets.length < 10) {
      var rocket = new Rocket(width / 2, height);
      rocket.explosionColor = Math.floor((Math.random() * 360) / 10) * 10;
      rocket.vel.y = Math.random() * -3 - 4;
      rocket.vel.x = Math.random() * 6 - 3;
      rocket.size = 8;
      rocket.shrink = 0.999;
      rocket.gravity = 0.01;
      setRockets([...rockets, rocket]);
    }
  };

  useInterval(launch, 800);
  useInterval(loop, 1000 / 50);

  // console.log(particles.length);
  return (
    <svg className="firework" style={{ width, height }}>
      <defs>
        <linearGradient id="grad1" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop
            offset="0%"
            style={{
              stopColor: 'rgb(255,0,0)',
              stopOpacity: 1,
            }}
          />
          <stop
            offset="100%"
            style={{
              stopColor: 'rgba(255,0,0,0)',
              stopOpacity: 1,
            }}
          />
        </linearGradient>
      </defs>
      {particles.map((particle, index) => {
        const x = particle.pos.x;
        const y = particle.pos.y;
        const s = particle.flick
          ? Math.random() * particle.size + particle.size
          : particle.size;

        return <circle key={index} cx={x} cy={y} r={s} fill="yellow" />;
      })}
      {rockets.map((rocket, index) => {
        const x = rocket.pos.x;
        const y = rocket.pos.y;
        const s = rocket.flick
          ? (Math.random() * rocket.size) / 2 + rocket.size / 2
          : rocket.size / 2;

        // return <circle key={index} cx={x} cy={y} r={s} fill="red" />;
        return (
          <line
            key={index}
            x1={width / 2}
            y1={height}
            x2={x}
            y2={y}
            stroke="url(#grad1)"
            strokeWidth={5}
          />
        );
      })}
    </svg>
  );
};

export default Firework;
